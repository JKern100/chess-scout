import { GoogleGenAI } from "@google/genai";
import crypto from "crypto";

export type SubjectType = "self" | "opponent";

export type NarrativeResult = {
  quick_summary: string;
  comprehensive_report: string;
  generated_at: string;
  subject_type: SubjectType;
  model_used: string;
  debug?: {
    prompt_hash: string;
    used_system_instruction: boolean;
    used_rewrite: boolean;
  };
};

type ProfilePayload = {
  subject_type?: SubjectType;
  analysis_subject?: SubjectType;
  analysis_context: {
    subject_type: SubjectType;
  };
  opponent_profile: any;
  style_markers: any[];
};

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
// Use the model name without 'models/' prefix for the new SDK
const GEMINI_MODEL = process.env.GEMINI_TUNED_MODEL || "gemini-2.0-flash-exp";

const SYSTEM_INSTRUCTION = `You are ChessScout CoachGPT, a professional chess coach and scouting analyst.

You receive a structured JSON profile generated by ChessScout, describing a chess player’s games, openings, repertoire, style metrics, and results.

Your task: produce data-grounded, coach-quality analysis and preparation guidance strictly derived from the JSON. Do not invent data, tools, or certainty.

--------------------------------------------------------------------
1) MODE FLAG (MANDATORY, SINGLE SOURCE OF TRUTH)

The input JSON will include:

subject_type = "self"  → the JSON describes the user
subject_type = "opponent" → the JSON describes another player the user wants to analyze

If subject_type is missing, assume: subject_type = "opponent"

IMPORTANT:
- Do NOT look for any other flags (e.g., analysis_subject). Only use subject_type.
- If subject_type = "self", do NOT describe the subject as “the opponent” or “this opponent”.
--------------------------------------------------------------------
2) NARRATIVE VOICE & TONE (CRITICAL)

If subject_type = "self":
- Use second person (“you”, “your”).
- Tone: encouraging, constructive, improvement-oriented.
- Allowed examples:
  - “You may benefit from…”
  - “This suggests an opportunity to improve…”
  - “A practical next step would be…”

If subject_type = "opponent":
- Use third person, referring to the player by username or “the opponent”.
- Tone: neutral, practical, scouting-oriented.
- Allowed examples:
  - “This player tends to…”
  - “You may want to prepare…”
  - “You might take advantage of…”

NEVER mix perspectives or tones in the same report.
--------------------------------------------------------------------
3) PERSPECTIVE LABELING (MANDATORY)

Always explicitly state who is White and who is Black.

Allowed phrasing:
- “When you play White…”
- “When you play Black…”
- “When the opponent plays White…”
- “When the opponent plays Black…”

Forbidden phrasing:
- “As White…”
- “As Black…”

This rule overrides stylistic preference.
--------------------------------------------------------------------
4) OUTPUT FORMAT (MANDATORY, MUST MATCH EXACTLY)

You must produce TWO outputs, clearly separated with these exact headings:

VERSION 1: QUICK SUMMARY
<one paragraph only>

VERSION 2: COMPREHENSIVE REPORT
<structured report>

No extra titles before VERSION 1.
No emojis.
Markdown only.
--------------------------------------------------------------------
5) VERSION 1: QUICK SUMMARY (STRICT)

Exactly ONE paragraph.
Maximum 6–7 sentences.
Must include (in this order):
1) Overall style (grounded in JSON, calibrated language)
2) Opening tendencies (White + Black tendencies, no invented specifics)
3) One clear strength (data-grounded)
4) One clear weakness / exploitable pattern (data-grounded)
5) One practical next step (self) OR one preparation tip (opponent)

Do NOT write a preface like “I analyzed the profile…”.
Do NOT mention “opponent profile” if subject_type="self".
No exact numbers unless explicitly supported by JSON.
--------------------------------------------------------------------
6) VERSION 2: COMPREHENSIVE REPORT (REQUIRED STRUCTURE)

Follow this structure:

1. Snapshot
- Player / platform
- Ratings (if present)
- Games analyzed
- Date range
- Dominant time control
- Filters used

2. Results & Competitive Profile
- Overall W/D/L (only if present)
- Performance by color
- Interpretation: draw tendency (low/moderate/high), risk profile (solid/balanced/volatile)

3. Opening & Repertoire Tendencies
Use explicit perspective labeling.

When the player plays White:
- Most frequent openings

When the player plays Black vs 1.e4:
- Preferred defenses
- Predictability: highly predictable / moderately varied / varied (from repertoire data)

When the player plays Black vs 1.d4:
- Preferred defenses
- Predictability classification

Do NOT predict exact move sequences unless repertoire depth explicitly supports it.
--------------------------------------------------------------------
7) MOVE OWNERSHIP & AGENCY (CRITICAL)

Respect who controls which decisions:
- Black chooses defenses and replies (…c5, …d5, …e6, …Nf6)
- White chooses systems and setups (Nf3, c4, c3, g3)

Never attribute White choices to Black or vice versa.
Required phrasing examples:
- “From White’s side…”
- “When facing this defense, White most often…”
- “As Black, this player chooses…”
--------------------------------------------------------------------
8) STYLE & STRUCTURAL TENDENCIES (DATA-GROUNDED)

Based only on segments.*.style:
- Castling preference (explicitly state denominator)
- Castling timing
- Queen trades by move 20
- Pawn storms after castling
- Aggression profile:
  - pawn advances by move 10
  - captures by move 15
  - checks by move 15
--------------------------------------------------------------------
9) TIME CONTROL SHIFTS

Compare segments (e.g., blitz vs all).
Only highlight meaningful differences.
If similar: explicitly say “style remains consistent across time controls”.
--------------------------------------------------------------------
10) COACH INTERPRETATION

3–4 synthesized insights:
- tie each to concrete metrics
- use calibrated language (“tends to”, “suggests”, “may indicate”)
--------------------------------------------------------------------
11) PREPARATION & TRAINING GUIDANCE (CHESSSCOUT-AWARE)

Must explicitly reference ChessScout tools/workflows.

If subject_type = "self":
- Performance Analysis: Result Charts + Timeline Views
- Opening Prep: Opening Trees + Opening Success Rates
- Simulation: Game Simulation
- Style Profiling: Style Spectrum + Style Markers
- Filtering: time control/date range/color/opponent strength

If subject_type = "opponent":
- Opening Prep: Opening Trees against their most frequent choices
- Simulation: Game Simulation to mimic tendencies
- Pattern Recognition: Move Frequency
- Targeting: Result Charts to find weak color/time controls
--------------------------------------------------------------------
12) ACTION PLAN (TOOL-SPECIFIC)

Provide:
- 3 concrete drills (each mapped to a ChessScout tool)
- 2 repertoire actions (tested via Game Simulation; validated via Opening Success Rates)
- 1 review habit (e.g., monthly Timeline View review)

Language must match subject_type.
--------------------------------------------------------------------
13) DATA GAPS & CONFIDENCE NOTES

Explicitly list what is not measured.
If engineInsights is null: state that blunders, sacrifices, eval swings, and accuracy are not assessed.
Flag small samples and downgrade confidence where appropriate.
--------------------------------------------------------------------
14) VARIATION SPECIFICITY

You may reference opening families.
Only name sub-variations if JSON explicitly provides sub-variation frequency support.
--------------------------------------------------------------------
15) GUARDRAILS

Never invent numbers/percentages.
Never use absolute language (“always”, “never”) unless explicitly supported.
Never use engine-based language without engine data.
Always calibrate claims to data strength.
--------------------------------------------------------------------
FINAL INSTRUCTION

Output exactly:
VERSION 1: QUICK SUMMARY
(one paragraph)

VERSION 2: COMPREHENSIVE REPORT
(full structured report)

Use the correct narrative voice based on subject_type.`;

function parseNarrativeResponse(text: string): { quick_summary: string; comprehensive_report: string } {
  console.log("[GeminiNarrative] Parsing response, total length:", text.length);
  console.log("[GeminiNarrative] First 500 chars:", text.slice(0, 500));
  
  let quick_summary = "";
  let comprehensive_report = "";

  // Strategy 1: Look for explicit section markers with various formats
  // The AI might output: "## Quick Summary", "# Quick Summary", "**Quick Summary**", "Quick Summary:", etc.
  const quickSummaryPatterns = [
    /VERSION\s*1\s*:\s*QUICK\s*SUMMARY\s*\n+([\s\S]*?)(?=\nVERSION\s*2\s*:\s*COMPREHENSIVE\s*REPORT\b|\n#{1,3}\s|$)/i,
    /#{1,3}\s*Quick Summary\s*\n+([\s\S]*?)(?=\n#{1,3}\s|$)/i,
    /\*\*Quick Summary\*\*\s*\n+([\s\S]*?)(?=\n\*\*|$)/i,
    /Quick Summary:?\s*\n+([\s\S]*?)(?=\n#{1,3}\s|\nComprehensive|\n\*\*Comprehensive|$)/i,
  ];

  const comprehensivePatterns = [
    /VERSION\s*2\s*:\s*COMPREHENSIVE\s*REPORT\s*\n+([\s\S]*?)$/i,
    /#{1,3}\s*Comprehensive Report\s*\n+([\s\S]*?)$/i,
    /\*\*Comprehensive Report\*\*\s*\n+([\s\S]*?)$/i,
    /Comprehensive Report:?\s*\n+([\s\S]*?)$/i,
  ];

  // Try to find Quick Summary
  for (const pattern of quickSummaryPatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      quick_summary = match[1].trim();
      console.log("[GeminiNarrative] Found quick summary with pattern, length:", quick_summary.length);
      break;
    }
  }

  // Try to find Comprehensive Report
  for (const pattern of comprehensivePatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      comprehensive_report = match[1].trim();
      console.log("[GeminiNarrative] Found comprehensive report with pattern, length:", comprehensive_report.length);
      break;
    }
  }

  // Strategy 2: If we found comprehensive but not quick, extract quick from before comprehensive header
  if (!quick_summary && comprehensive_report) {
    const comprehensiveIndex = text.search(
      /VERSION\s*2\s*:\s*COMPREHENSIVE\s*REPORT|#{1,3}\s*Comprehensive Report|\*\*Comprehensive Report\*\*|Comprehensive Report:/i
    );
    if (comprehensiveIndex > 0) {
      const beforeComprehensive = text.slice(0, comprehensiveIndex);
      // Remove any Quick Summary header
      quick_summary = beforeComprehensive
        .replace(/^VERSION\s*1\s*:\s*QUICK\s*SUMMARY\s*\n*/i, "")
        .replace(/^#{1,3}\s*Quick Summary\s*\n*/i, "")
        .replace(/^\*\*Quick Summary\*\*\s*\n*/i, "")
        .replace(/^Quick Summary:?\s*\n*/i, "")
        .trim();
      console.log("[GeminiNarrative] Extracted quick summary from before comprehensive, length:", quick_summary.length);
    }
  }

  // Strategy 3: If still no sections found, try splitting by first major heading after intro
  if (!quick_summary && !comprehensive_report) {
    console.log("[GeminiNarrative] No sections found, trying fallback split");
    // Look for the first ## or # heading that isn't Quick Summary
    const firstHeadingMatch = text.match(/\n(#{1,2})\s+(?!Quick Summary)([^\n]+)/i);
    if (firstHeadingMatch && firstHeadingMatch.index !== undefined) {
      quick_summary = text.slice(0, firstHeadingMatch.index).trim();
      comprehensive_report = text.slice(firstHeadingMatch.index).trim();
    } else {
      // Final fallback: first paragraph is quick, rest is comprehensive
      const firstDoubleNewline = text.indexOf("\n\n");
      if (firstDoubleNewline > 0) {
        quick_summary = text.slice(0, firstDoubleNewline).trim();
        comprehensive_report = text.slice(firstDoubleNewline + 2).trim();
      } else {
        quick_summary = text.trim();
        comprehensive_report = text.trim();
      }
    }
  }

  // Clean up: remove the header from quick_summary if it starts with one
  quick_summary = quick_summary
    .replace(/^VERSION\s*1\s*:\s*QUICK\s*SUMMARY\s*\n*/i, "")
    .replace(/^#{1,3}\s*Quick Summary\s*\n*/i, "")
    .replace(/^\*\*Quick Summary\*\*\s*\n*/i, "")
    .trim();

  console.log("[GeminiNarrative] Final quick_summary length:", quick_summary.length);
  console.log("[GeminiNarrative] Final comprehensive_report length:", comprehensive_report.length);
  console.log("[GeminiNarrative] Quick summary preview:", quick_summary.slice(0, 200));

  return { quick_summary, comprehensive_report };
}

function isCompliantNarrative(params: {
  subjectType: SubjectType;
  quickSummary: string;
  comprehensiveReport: string;
}): boolean {
  const quick = (params.quickSummary ?? "").trim();
  const comp = (params.comprehensiveReport ?? "").trim();
  if (!quick || !comp) return false;

  const lowerQuick = quick.toLowerCase();

  if (/(^|\b)(okay,\s*i\s*have|i\s*(have|'ve)\s*analyzed|here'?s\s+a\s+breakdown|opponent\s+analysis)\b/i.test(quick)) {
    return false;
  }

  if (/\n\s*\n/.test(quick)) return false;

  if (params.subjectType === "self") {
    if (!/\byou\b/i.test(quick) || !/\byour\b/i.test(quick)) return false;
    if (/\bopponent\b/i.test(lowerQuick) || /\bthis\s+player\b/i.test(lowerQuick)) return false;
  }

  if (quick.length < 120) return false;
  if (comp.length < 400) return false;

  return true;
}

export async function generateNarrative(params: {
  profileJson: any;
  styleMarkers: any[];
  subjectType: SubjectType;
  username: string;
  platform: string;
}): Promise<NarrativeResult> {
  console.log("[GeminiNarrative] Starting generation for", params.username, "with model:", GEMINI_MODEL);
  
  if (!GEMINI_API_KEY) {
    console.error("[GeminiNarrative] GEMINI_API_KEY environment variable is not set");
    throw new Error("GEMINI_API_KEY environment variable is not set");
  }

  console.log("[GeminiNarrative] API key found, initializing Gemini AI with new SDK");
  const ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });

  const payload: ProfilePayload = {
    subject_type: params.subjectType,
    analysis_subject: params.subjectType,
    analysis_context: {
      subject_type: params.subjectType,
    },
    opponent_profile: {
      username: params.username,
      platform: params.platform,
      ...params.profileJson,
    },
    style_markers: params.styleMarkers,
  };

  try {
    console.log("[GeminiNarrative] Calling generateContent with model:", GEMINI_MODEL);
    
    const config: any = {
      model: GEMINI_MODEL,
    };

    const usedSystemInstruction = !GEMINI_MODEL.startsWith("tunedModels/");
    const promptHash = crypto.createHash("sha256").update(SYSTEM_INSTRUCTION).digest("hex").slice(0, 12);
    
    // Add system instruction if not using a tuned model
    if (usedSystemInstruction) {
      config.systemInstruction = [{ text: SYSTEM_INSTRUCTION }];
    }

    const strictUserPrompt =
      `MODE: subject_type=${params.subjectType}\n` +
      `Return markdown with EXACTLY these headings:\n` +
      `VERSION 1: QUICK SUMMARY\n` +
      `VERSION 2: COMPREHENSIVE REPORT\n` +
      `Quick summary must be 1 paragraph (6-7 sentences), not a preface.\n` +
      `If subject_type=self: use second person (you/your) and do NOT say opponent.\n` +
      `If subject_type=opponent: use third person (they/the player/opponent).\n\n` +
      `JSON INPUT:\n${JSON.stringify(payload)}`;

    const response = await ai.models.generateContent({
      ...config,
      contents: [{ role: "user", parts: [{ text: strictUserPrompt }] }],
    });

    const text = response.text ?? "";
    console.log("[GeminiNarrative] Got response, length:", text.length);

    let { quick_summary, comprehensive_report } = parseNarrativeResponse(text);
    let usedRewrite = false;

    const firstPassOk = isCompliantNarrative({
      subjectType: params.subjectType,
      quickSummary: quick_summary,
      comprehensiveReport: comprehensive_report,
    });

    if (!firstPassOk) {
      const rewritePrompt =
        `Rewrite the content below to comply EXACTLY with the required format and mode.\n` +
        `MODE: subject_type=${params.subjectType}\n` +
        `Output must be markdown and must start with:\n` +
        `VERSION 1: QUICK SUMMARY\n` +
        `(one paragraph, 6-7 sentences, no preface)\n\n` +
        `VERSION 2: COMPREHENSIVE REPORT\n` +
        `(full structured report)\n\n` +
        `Self mode must use you/your and must not call the subject an opponent.\n\n` +
        `JSON INPUT (do not repeat it verbatim unless needed for grounding):\n${JSON.stringify(payload)}\n\n` +
        `CONTENT TO REWRITE:\n${text}`;

      const rewriteResponse = await ai.models.generateContent({
        ...config,
        contents: [{ role: "user", parts: [{ text: rewritePrompt }] }],
      });

      const rewriteText = rewriteResponse.text ?? "";
      console.log("[GeminiNarrative] Got rewrite response, length:", rewriteText.length);
      const parsed = parseNarrativeResponse(rewriteText);
      quick_summary = parsed.quick_summary;
      comprehensive_report = parsed.comprehensive_report;

      usedRewrite = true;

      const rewriteOk = isCompliantNarrative({
        subjectType: params.subjectType,
        quickSummary: quick_summary,
        comprehensiveReport: comprehensive_report,
      });

      if (!rewriteOk) {
        throw new Error(
          `Narrative generation failed compliance checks (subject_type=${params.subjectType}, prompt_hash=${promptHash}, used_rewrite=true)`
        );
      }
    }

    return {
      quick_summary,
      comprehensive_report,
      generated_at: new Date().toISOString(),
      subject_type: params.subjectType,
      model_used: GEMINI_MODEL,
      debug: {
        prompt_hash: promptHash,
        used_system_instruction: usedSystemInstruction,
        used_rewrite: usedRewrite,
      },
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    console.error("[GeminiNarrative] Generation failed:", message);
    throw new Error(`Narrative generation failed: ${message}`);
  }
}

export async function generateNarrativeWithRetry(params: {
  profileJson: any;
  styleMarkers: any[];
  subjectType: SubjectType;
  username: string;
  platform: string;
  maxRetries?: number;
}): Promise<NarrativeResult> {
  const maxRetries = params.maxRetries ?? 2;
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await generateNarrative(params);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      console.warn(`[GeminiNarrative] Attempt ${attempt + 1} failed:`, lastError.message);
      
      if (attempt < maxRetries) {
        // Wait before retry (exponential backoff)
        await new Promise((resolve) => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
      }
    }
  }

  throw lastError ?? new Error("Narrative generation failed after retries");
}
